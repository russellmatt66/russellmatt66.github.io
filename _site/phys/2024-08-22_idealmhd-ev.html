<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <!-- Enable responsiveness on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <title>The Eigenvalues of Ideal Magnetohydrodynamics</title>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="shortcut icon" type="image/png" href="/assets/killerwhaleph.png">
</head>

  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ['\[','\]'] ],
    displayMath: [ ['$$','$$'], ['\\[','\\]'] ],
    processEscapes: true
  },
  TeX: {
    equationNumbers: {autoNumber: "all" },
    extensions: ["AMSmath.js", "AMSsymbols.js"]
  },
  "HTML-CSS": {
    fonts: ["Latin-Modern"],
    mtextFontInherit: true
  }
});

MathJax.Hub.Register.StartupHook("TeX Jax Ready",function() {
  var TEX = MathJax.InputJax.TeX;
  TEX.Definitions.Add({
    macros: {
      ranktwotensor: ["Macro","{\\overline{\\overline{#1}}}",1],
      rowvec: ["Macro","{\\begin{bmatrix} #1 \\end{bmatrix}}", 1],
      colvec: ["Macro","{\\begin{bmatrix} #1 \\end{bmatrix}}", 1],
      quantity:["Macro","{\\left\\{ #1 \\right\\}}",1],
      qty:["Macro","{\\left\\{ #1 \\right\\}}",1],
      pqty:["Macro","{\\left( #1 \\right)}",1],
      bqty:["Macro","{\\left[ #1 \\right]}",1],
      vqty:["Macro","{\\left\\vert #1 \\right\\vert}",1],
      Bqty:["Macro","{\\left\\{ #1 \\right\\}}",1],
      absolutevalue:["Macro","{\\left\\vert #1 \\right\\vert}",1],
      abs:["Macro","{\\left\\vert #1 \\right\\vert}",1],
      norm:["Macro","{\\left\\Vert #1 \\right\\Vert}",1],
      evaluated:["Macro","{#1 \\vert}",1],
      eval:["Macro","{#1 \\vert}",1],
      order:["Macro","{\\mathcal{O} \\left( #1 \\right)}",1],
      commutator:["Macro","{\\left[ #1 , #2 \\right]}",2],
      comm:["Macro","{\\left[ #1 , #2 \\right]}",2],
      anticommutator:["Macro","{\\left\\{ #1 , #2 \\right\\}}",2],
      acomm:["Macro","{\\left\\{ #1 , #2 \\right\\}}",2],
      poissonbracket:["Macro","{\\left\\{ #1 , #2 \\right\\}}",2],
      pb:["Macro","{\\left\\{ #1 , #2 \\right\\}}",2],
      vectorbold:["Macro","{\\boldsymbol{ #1 }}",1],
      vb:["Macro","{\\boldsymbol{ #1 }}",1],
      vectorarrow:["Macro","{\\vec{\\boldsymbol{ #1 }}}",1],
      va:["Macro","{\\vec{\\boldsymbol{ #1 }}}",1],
      vectorunit:["Macro","}}",1],
      vu:["Macro","}}",1],
      dotproduct:["Macro","{\\boldsymbol\\cdot}"],
      vdot:["Macro","{\\boldsymbol\\cdot}"],
      crossproduct:["Macro","{\\boldsymbol\\times}"],
      cross:["Macro","{\\boldsymbol\\times}"],
      cp:["Macro","{\\boldsymbol\\times}"],
      gradient:["Macro","{\\boldsymbol\\nabla}"],
      grad:["Macro","{\\boldsymbol\\nabla}"],
      divergence:["Macro","{\\grad\\vdot}"],
      div:["Macro","{\\grad\\vdot}"],
      curl:["Macro","{\\grad\\cross}"],
      laplacian:["Macro","{\\nabla^2}"],
      tr:["Macro","{\\operatorname{tr}}"],
      Tr:["Macro","{\\operatorname{Tr}}"],
      rank:["Macro","{\\operatorname{rank}}"],
      erf:["Macro","{\\operatorname{erf}}"],
      Res:["Macro","{\\operatorname{Res}}"],
      principalvalue:["Macro","{\\mathcal{P}}"],
      pv:["Macro","{\\mathcal{P}}"],
      PV:["Macro","{\\operatorname{P.V.}}"],
      Re:["Macro","{\\operatorname{Re} \\left\\{ #1 \\right\\}}",1],
      Im:["Macro","{\\operatorname{Im} \\left\\{ #1 \\right\\}}",1],
      qqtext:["Macro","{\\quad\\text{ #1 }\\quad}",1],
      qq:["Macro","{\\quad\\text{ #1 }\\quad}",1],
      qcomma:["Macro","{\\text{,}\\quad}"],
      qc:["Macro","{\\text{,}\\quad}"],
      qcc:["Macro","{\\quad\\text{c.c.}\\quad}"],
      qif:["Macro","{\\quad\\text{if}\\quad}"],
      qthen:["Macro","{\\quad\\text{then}\\quad}"],
      qelse:["Macro","{\\quad\\text{else}\\quad}"],
      qotherwise:["Macro","{\\quad\\text{otherwise}\\quad}"],
      qunless:["Macro","{\\quad\\text{unless}\\quad}"],
      qgiven:["Macro","{\\quad\\text{given}\\quad}"],
      qusing:["Macro","{\\quad\\text{using}\\quad}"],
      qassume:["Macro","{\\quad\\text{assume}\\quad}"],
      qsince:["Macro","{\\quad\\text{since}\\quad}"],
      qlet:["Macro","{\\quad\\text{let}\\quad}"],
      qfor:["Macro","{\\quad\\text{for}\\quad}"],
      qall:["Macro","{\\quad\\text{all}\\quad}"],
      qeven:["Macro","{\\quad\\text{even}\\quad}"],
      qodd:["Macro","{\\quad\\text{odd}\\quad}"],
      qinteger:["Macro","{\\quad\\text{integer}\\quad}"],
      qand:["Macro","{\\quad\\text{and}\\quad}"],
      qor:["Macro","{\\quad\\text{or}\\quad}"],
      qas:["Macro","{\\quad\\text{as}\\quad}"],
      qin:["Macro","{\\quad\\text{in}\\quad}"],
      differential:["Macro","{\\text{d}}"],
      dd:["Macro","{\\text{d}}"],
      derivative:["Macro","{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}",2],
      dv:["Macro","{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}",2],
      partialderivative:["Macro","{\\frac{\\partial{ #1 }}{\\partial{ #2 }}}",2],
      <!-- pdv:["Macro","{\\frac{\\partial{ #1 }}{\\partial{ #2 }}}",2], -->
      pdv:["Macro","{\\frac{\\partial^{#2}{ #1 }}{\\partial{ #3^{#2} }}}",3],
      variation:["Macro","{\\delta}"],
      "var":["Macro","{\\delta}"],
      functionalderivative:["Macro","{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}",2],
      fdv:["Macro","{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}",2],
      ket:["Macro","{\\left\\vert { #1 } \\right\\rangle}",1],
      bra:["Macro","{\\left\\langle { #1} \\right\\vert}",1],
      innerproduct:["Macro","{\\left\\langle {#1} \\mid { #2} \\right\\rangle}",2],
      braket:["Macro","{\\left\\langle {#1} \\mid { #2} \\right\\rangle}",2],
      outerproduct:["Macro","{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}",2],
      dyad:["Macro","{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}",2],
      ketbra:["Macro","{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}",2],
      op:["Macro","{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}",2],
      expectationvalue:["Macro","{\\left\\langle {#1 } \\right\\rangle}",1],
      expval:["Macro","{\\left\\langle {#1 } \\right\\rangle}",1],
      ev:["Macro","{\\left\\langle {#1 } \\right\\rangle}",1],
      matrixelement:["Macro","{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}",3],
      matrixel:["Macro","{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}",3],
      mel:["Macro","{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}",3]
    }
  });
});
</script>

<!-- <script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script> -->
<!-- <script type="text/javascript">
  window.MathJax = {
    tex: {
      extensions: ["AMSmath.js", "AMSsymbols.js"],
      packages: {'[+]': ['mhchem']}
    },
    loader: {
      load: ['[tex]/mhchem']
    }
  };
</script> -->

<script 
  src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_HTMLorMML' async>
</script>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RT0E6XZ74J"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-RT0E6XZ74J');
</script>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="GPU, HPC, fusion energy, and computational science articles">
  <meta name="keywords" content="GPU,HPC,physics,fusion,fusion energy,computational science,c,cuda,python">

  <body>
    <header>
<nav>
  <ul>
    <li class="navhome"><a href="/">Physics In Parallel</a></li>
    
    <li><a href="/phys/">Physics</a>
    
    <li><a href="/math/">Mathematics</a>
    
    <li><a href="/gpu/">GPU</a>
    
    <li><a href="/fusion/">Fusion</a>
    
    <li><a href="/compsci/">CS</a>
    
  </ul>
</nav>
</header>

    <div class="container">
      <h1>The Eigenvalues of Ideal Magnetohydrodynamics</h1>
<p class="meta" style="color:#888">26 Aug 2024</p>
<div class="post">
  <h3 id="recap">Recap</h3>
<p>     Previously, I have written about <a href="./2024-08-15_fluxjacobian">the Flux Jacobians of Ideal MHD</a>, which are an idea that is central to this post. Recapping briefly, Ideal MHD is the simplest, meaningful, fluid description of a plasma. Its main application is in the field of fusion energy, where it is used to describe the equilibrium of magnetic configurations. In the absence of external sources of mass, momentum, energy, and magnetic field, we can write the system in the following form,</p>

\[\label{eq:imhd_system_fj}
\pdv{\vec{Q}}{}{t} + \mathbf{A}\pdv{\vec{Q}}{}{x} + \mathbf{B}\pdv{\vec{Q}}{}{y} + \mathbf{C}\pdv{\vec{Q}}{}{z} = 0\]

<p>where $\vec{Q}$ are the <a href="./2024-08-15_fluxjacobian#eq:imhdvars">Ideal MHD variables</a>, and $\mathbf{A}, \mathbf{B}$, and $\mathbf{C}$, are the <a href="./2024-08-15_fluxjacobian#the-flux-jacobians">Flux Jacobians</a>. These mathematical objects express how the fluxes vary with respect to the fluid variables, and they contain important information about the properties of the system related to the type of the equations, their characteristics, and stability.</p>

<h3 id="eigenvalues-and-eigenvectors">Eigenvalues and Eigenvectors</h3>
<p>     If you study physics, or engineering, to a serious degree, then you will eventually run into the concepts of an “eigenvalue”, and an “eigenvector”. If you are already familiar, and comfortable, with what these are, and just want to get to the meat of this post <a href="#the-ideal-mhd-eigenvalues">where the eigenvalues of the Ideal MHD Flux Jacobians are calculated</a>, then please follow this link, and feel free to skip this section as it will be a brief introduction to these concepts.</p>

<p>     These, somewhat intimidating, names bely deceptively simple ideas, but which are also devilishly rich with detail to understand the deeper you go, and understanding which begins by talking about the idea of a <em>system</em>. Intuitively, you can understand a system as something where input goes in, something happens to it, and output comes out. For example, the American education system takes in children around the age of five, obliges them to sit down and learn for seven hours a day, five days a week, asks them do homework for another three starting when they reach high school, and keeps them in this cycle for thirteen years. What comes out of this system is hopefully an educated, well-socialized populace of workers who can think critically, make informed decisions, and perform tasks which add value to society in exchange for a cut of this value in the form of monetary compensation which allows them to meet their basic needs, and do things which they find fulfilling.</p>

<p>     The difference in physics, and engineering, is that the systems which we study in these fields are rigorously defined mathematically, rather than just described qualitatively, meaning we have a clear idea of what the inputs, outputs, and transformation are. A <strong>matrix</strong> is the primary form in which a system is defined, and it is just a collection of numbers, (in the form of a rank-2 tensor, to be specific), that has two dimensions to its structure. For example,</p>

\[\mathbf{R} = \begin{bmatrix}
2 &amp; 1 &amp; 3 \\
1 &amp; 3 &amp; -2 \\
0 &amp; 5 &amp; -1
\end{bmatrix}\]

<p>is the matrix which describes the transformation from one coordinate system, $(x_{1}, y_{1}, z_{1})$ to another $(x_{2}, y_{2}, z_{2})$, that is defined by the following system of equations,</p>

\[\begin{align}
x_{2} &amp;= 2x_{1} + y_{1} + 3z_{1} \\
y_{2} &amp;= x_{1} + 3y_{1} - 2z_{1} \\
z_{2} &amp;= 5y_{1} - z_{1}
\end{align}\]

<p>What this means, in practice, is if we had a vector, which is a one-dimensional way of storing information, that we were looking at in the first coordinate system, where it was described by the numbers,</p>

\[\vec{u}_{in1} = \begin{bmatrix}
4 \\
-3 \\
1
\end{bmatrix}\]

<p>then, if we were to look at it in the second coordinate system, it would be described by a new triplet of numbers,</p>

\[\vec{u}_{in2} = \mathbf{R}\vec{u}_{in1} = \begin{bmatrix}
4*2 - 3*1 + 1*3 \\
4*1 - 3*3 + 1*(-2) \\
4*0 - 3*5 - 1*1
\end{bmatrix}
= \begin{bmatrix}
8 \\
-7 \\
-16
\end{bmatrix}\]

<p>All vectors can be boiled down to a magnitude, and a direction. The <em>magnitude</em> of a vector is a measure of how long it is, and its direction gives a sense for its orientation. If we compare the magnitude of these two vectors, and their orientations, we will notice they’re different when viewed in these two coordinate systems, even though we’re talking about the <strong>same</strong> underlying mathematical object. <em>Great</em>, you may be thinking, <em>when do we get to what eigenvectors, and eigenvalues, are?</em></p>

<p>     For a given system, there is a set of vectors which <em>do not rotate</em> when the system is applied to it. Their lengths will change, but their orientations will not. These vectors are termed <strong>eigenvectors</strong>, and the factors by which their lengths change, are the <strong>eigenvalues</strong>. In principle, the eigenvalues, $\{\lambda\}$, of a system, $\mathbf{A}$, can be determined by solving for the roots of a <em>characteristic polynomial</em>, which is defined by the equation,</p>

\[det(\mathbf{A} - \lambda\mathbf{I}) = 0\]

<h3 id="determinants">Determinants</h3>

<p>The <em>determinant</em> is a function, $det()$, which takes in an $N\times N$ matrix of real numbers, and returns a scalar, so rigorously speaking, $det: \mathbb{R}^{N\times N} \rightarrow \mathbb{R}$. The determinant of a $2\times 2$ matrix is defined in the following manner,</p>

\[det(\mathbf{A}_{2by2}) = \begin{vmatrix}
a &amp; b \\
c &amp; d 
\end{vmatrix} = ad - bc\]

<p>Notice that computing this requires the performance of 3 floating-point operations (FPOs), so we shall say that,</p>

\[F(2) = 3\]

<p>where $F(N)$ expresses the amount of work it takes to compute the determinant of an $N\times N$ matrix. $F(2)$ is a trivial amount of work for a computer, and a straightforward task for a human with a calculator. The determinant of a $3\times 3$ matrix can be expressed as a sum of determinants of $2\times 2$ sub-matrices,</p>

\[det(\mathbf{A}_{3by3}) = \begin{vmatrix}
a &amp; b &amp; c \\
d &amp; e &amp; f \\
g &amp; h &amp; i
\end{vmatrix} = 
a \begin{vmatrix}
e &amp; f \\
h &amp; i
\end{vmatrix}
- b \begin{vmatrix}
d &amp; f \\
g &amp; i
\end{vmatrix}
+ c \begin{vmatrix}
d &amp; e \\
g &amp; h 
\end{vmatrix}\]

<p>     If you have taken a course in linear algebra, or calculus, this formula will hopefully be familiar to you. You might also remember that it doesn’t matter what row, or column, that you use as the leading factors of the sub-matrix expansion, so long as you remember to multiply the ones whose row and column index sum to an odd number, by $-1$. Both of these facts are important, the former because it is a way of drastically reducing the amount of work necessary to compute a determinant for matrices that have an appreciable number of zeros along a certain row or column, as you can choose to expand along this dimension, and therefore trivialize much of the algebra. In general, the amount of work we have to do to compute a $3\times 3$ determinant is,</p>

\[F(3) = 3 * F(2) + 3 + 2\]

<p>     The first term in the above is the number of FPOs that it takes to compute the determinants of the sub-matrices, the second term is the number of FPOs to multiply these by their leading factors, and then the last term is the number of addition operations to sum everything together. The determinant of a $4\times 4$ matrix can be expressed as a sum of determinants of $3\times 3$ sub-matrices,</p>

\[det(\mathbf{A}_{4by4}) = \begin{vmatrix}
a &amp; b &amp; c &amp; d \\
e &amp; f &amp; g &amp; h \\
i &amp; j &amp; k &amp; l \\
m &amp; n &amp; o &amp; p
\end{vmatrix}
= a \begin{vmatrix}
f &amp; g &amp; h \\
j &amp; k &amp; l \\
n &amp; o &amp; p
\end{vmatrix}
- b \begin{vmatrix}
e &amp; g &amp; h \\
i &amp; k &amp; l \\
m &amp; o &amp; p
\end{vmatrix}
+ c \begin{vmatrix}
e &amp; f &amp; h \\
i &amp; j &amp; l \\
m &amp; n &amp; p
\end{vmatrix}
- d \begin{vmatrix}
e &amp; f &amp; g \\
i &amp; j &amp; k \\
m &amp; n &amp; o
\end{vmatrix}\]

<p>and so on, and so forth (larger dimensions not rendered here for obvious reasons). In general, for an $N\times N$ matrix, you will need to perform $N * F(N-1)$ FPOs to compute the sub-matrix determinants, $N$ more FPOs to multiply these together with their leading factors, and finally $N-1$ FPOs to sum everything together. This is a recurrence relation with $F(2) = 3$ as the base case,</p>

\[\begin{align}
F(N) &amp;= N * F(N-1) + 2N - 1 \\
&amp;= N(F(N-1) + 2) - 1 
\end{align}\]

<p><img src="../assets/phys/det_runtime.png" alt="Sub-Matrix Expansion Runtime" /></p>

<table>
  <thead>
    <tr>
      <th>N</th>
      <th>F(N)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <td>3</td>
      <td>14</td>
    </tr>
    <tr>
      <td>4</td>
      <td>63</td>
    </tr>
    <tr>
      <td>5</td>
      <td>324</td>
    </tr>
    <tr>
      <td>6</td>
      <td>1955</td>
    </tr>
    <tr>
      <td>7</td>
      <td>13698</td>
    </tr>
    <tr>
      <td>8</td>
      <td>109599</td>
    </tr>
  </tbody>
</table>

<p>     It is apparent, visualized in the above figure with a few values tabulated below, that computing the determinant is a very expensive, and time-consuming operation, roughly $O(N^{N})$. Just to hammer the point home, lines representing when an implementation would need GFLOPs, TFLOPs, PFLOPs, and EFLOPS of performance, in order to compute the problem in one second, are plotted alongside the data representing the runtime of the sub-matrix expansion algorithm. It is clear that this is not a wise, or worthwhile, task to be doing for unstructured matrices of any appreciable size, especially because doing so in the context of an eigenvalue problem yields an $Nth$ degree polynomial whose roots must then be found.</p>

<p>     In practice, instead of doing this, there are various <em>matrix decompositions</em><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> which can express the given matrix as a product of several other matrices, in one of which the eigenvalues are explicitly stored, that are employed for finding the eigenvalues of very large systems. High-performance libraries exist to do these computations on CPU, and GPU, which can be useful for implementing an adaptive timestep in a simulation. However, it should be noted that these decompositions are still expensive in of themselves, typically requiring between $O(N logN) \sim O(N^{3})$ work, and many of which are constrained as to what matrices they can operate on.</p>

<h3 id="the-ideal-mhd-eigenvalues">The Ideal MHD Eigenvalues</h3>
<p>     There are three matrices which are naturally relevant to Ideal Magnetohydrodynamics, namely, the <a href="./2024-08-15_fluxjacobian#appendix">Flux Jacobians</a>, $\mathbf{A}, \mathbf{B}$, and $\mathbf{C}$, which are written out in their full form where <a href="./2024-08-15_fluxjacobian#appendix">this hyperlink</a> leads. These matrices describe the rate at which the fluxes in the x-,y-, and z-directions, respectively, change with respect to a change in the fluid variables, $\vec{Q}$. From dimensional analysis of Equation (\ref{eq:imhd_system_fj}), you can see that the units of the Flux Jacobians must be that of velocity, distance over time, and so the eigenvalues of these matrices have a special interpretation as <em>characteristic speeds</em>. The stability of a numerical code that solves the Ideal MHD system <a href="./2024-08-15_fluxjacobian#motivation">depends on the value of these characteristic speeds</a>, in comparison to the characteristic speed of information propagation on the simulation mesh, namely,</p>

\[\begin{align}
\frac{\Delta t}{\Delta x}\abs{\lambda_{A,max}} + \frac{\Delta t}{\Delta y}\abs{\lambda_{B,max}} + \frac{\Delta t}{\Delta z}\abs{\lambda_{C,max}} \leq 1
\end{align}\]

<p>must be satisfied.</p>

<p>     The <strong>equation type</strong> of a system of PDEs is also defined by the eigenvalues of these matrices. There are three basic kinds of PDEs, <em>hyperbolic</em>, <em>parabolic</em>, and <em>elliptic</em>. Hyperbolic equations describe wave-like behavior, parabolic equations describe diffusion-like behavior, and elliptic equations describe steady-state behavior, or eigenvalue problems, where the challenge is determining a spectrum of numbers, instead of evolving the state of a dynamical system. What type a system of PDEs is has important implications for the kinds of numerical algorithms which are best suited to solving it. Furthermore, some PDEs can be of mixed-type, perhaps being hyperbolic in one part of the domain, and parabolic in another, due to nonuniformity in the coefficients. Fortunately, Ideal MHD does not have this problem, because the only coefficients in the system are two constants, $\gamma$, and $\mu_{0}$. As we will see, it is hyperbolic in the entire domain, which is based on its eigenvalues being real numbers with zero imaginary part.</p>

<p>     To begin finding the eigenvalues of Ideal Magnetohydrodynamics, we should first write out $\mathbf{A} - \lambda\mathbf{I}$ in a form that makes taking the determinant easier,</p>

\[\mathbf{A} - \lambda\mathbf{I} = 
\begin{bmatrix}
-\lambda &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
A_{21} &amp; A_{22} - \lambda &amp; A_{23} &amp; A_{24} &amp; A_{25} &amp; A_{26} &amp; A_{27} &amp; \gamma - 1 \\
-uv &amp; v &amp; u - \lambda &amp; 0 &amp; A_{35} &amp; A_{36} &amp; 0 &amp; 0 \\
-uw &amp; w &amp; 0 &amp; u - \lambda &amp; A_{45} &amp; 0 &amp; A_{47} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; -\lambda &amp; 0 &amp; 0 &amp; 0 \\
A_{61} &amp; A_{62} &amp; A_{63} &amp; 0 &amp; -v &amp; u - \lambda &amp; 0 &amp; 0 \\
A_{71} &amp; A_{72} &amp; 0 &amp; A_{74} &amp; -w &amp; 0 &amp; u - \lambda &amp; 0 \\
A_{81} &amp; A_{82} &amp; A_{83} &amp; A_{84} &amp; A_{85} &amp; A_{86} &amp; A_{87} &amp; u\gamma - \lambda
\end{bmatrix}\]

<p>The fifth row has only a single non-zero element, so if we perform our sub-matrix expansion about it, then we only have to take a single $7\times 7$ determinant,</p>

\[det(\mathbf{A} - \lambda\mathbf{I}) = 
-\lambda \begin{vmatrix}
-\lambda &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
A_{21} &amp; A_{22} - \lambda &amp; A_{23} &amp; A_{24} &amp; A_{26} &amp; A_{27} &amp; \gamma - 1 \\
-uv &amp; v &amp; u - \lambda &amp; 0 &amp; A_{36} &amp; 0 &amp; 0 \\
-uw &amp; w &amp; 0 &amp; u - \lambda &amp; 0 &amp; A_{47} &amp; 0 \\
A_{61} &amp; A_{62} &amp; A_{63} &amp; 0 &amp; u - \lambda &amp; 0 &amp; 0 \\
A_{71} &amp; A_{72} &amp; 0 &amp; A_{74} &amp; 0 &amp; u - \lambda &amp; 0 \\
A_{81} &amp; A_{82} &amp; A_{83} &amp; A_{84} &amp; A_{86} &amp; A_{87} &amp; u\gamma - \lambda
\end{vmatrix} = 0\]

<p>Unfortunately, the best choice we have here will result in two $6 \times 6$ determinants, but notice beforehand that we can already determine one of our eigenvalues just from inspecting the above equation, since $\lambda = 0$ is a valid solution to it. Consequently, we can focus on just when the determinant in the above is equal to zero, as any non-trivial solutions to the eigenvalues require it,</p>

\[\rightarrow - \lambda \begin{vmatrix}
A_{22} - \lambda &amp; A_{23} &amp; A_{24} &amp; A_{26} &amp; A_{27} &amp; \gamma - 1 \\
v &amp; u - \lambda &amp; 0 &amp; A_{36} &amp; 0 &amp; 0 \\
w &amp; 0 &amp; u - \lambda &amp; 0 &amp; A_{47} &amp; 0 \\
A_{62} &amp; A_{63} &amp; 0 &amp; u - \lambda &amp; 0 &amp; 0 \\
A_{72} &amp; 0 &amp; A_{74} &amp; 0 &amp; u - \lambda &amp; 0 \\
A_{82} &amp; A_{83} &amp; A_{84} &amp; A_{86} &amp; A_{87} &amp; u\gamma - \lambda
\end{vmatrix}
- \begin{vmatrix}
A_{21} &amp; A_{23} &amp; A_{24} &amp; A_{26} &amp; A_{27} &amp; \gamma - 1 \\
-uv &amp; u - \lambda &amp; 0 &amp; A_{36} &amp; 0 &amp; 0 \\
-uw &amp; 0 &amp; u - \lambda &amp; 0 &amp; A_{47} &amp; 0 \\
A_{61} &amp; A_{63} &amp; 0 &amp; u - \lambda &amp; 0 &amp; 0 \\
A_{71} &amp; 0 &amp; A_{74} &amp; 0 &amp; u - \lambda &amp; 0 \\
A_{81} &amp; A_{83} &amp; A_{84} &amp; A_{86} &amp; A_{87} &amp; u\gamma - \lambda
\end{vmatrix} = 0\]

<p>Space is getting tight, so let’s call these determinants $D_{1}$, and $D_{2}$, respectively. The best we can do in both cases is expand using the last column, and get two $5\times 5$ determinants out of each.</p>

\[\begin{align}
D_{1} &amp;= -(\gamma - 1)\begin{vmatrix}
v &amp; u - \lambda &amp; 0 &amp; A_{36} &amp; 0 \\
w &amp; 0 &amp; u - \lambda &amp; 0 &amp; A_{47} \\
A_{62} &amp; A_{63} &amp; 0 &amp; u - \lambda &amp; 0 \\
A_{72} &amp; 0 &amp; A_{74} &amp; 0 &amp; u - \lambda \\
A_{82} &amp; A_{83} &amp; A_{84} &amp; A_{86} &amp; A_{87}
\end{vmatrix}
+ (u\gamma - \lambda)\begin{vmatrix}
A_{22} - \lambda &amp; A_{23} &amp; A_{24} &amp; A_{26} &amp; A_{27} \\
v &amp; u - \lambda &amp; 0 &amp; A_{36} &amp; 0 \\
w &amp; 0 &amp; u - \lambda &amp; 0 &amp; A_{47} \\
A_{62} &amp; A_{63} &amp; 0 &amp; u - \lambda &amp; 0 \\
A_{72} &amp; 0 &amp; A_{74} &amp; 0 &amp; u - \lambda \\
\end{vmatrix} 
\\
D_{2} &amp;= -(\gamma - 1)\begin{vmatrix}
-uv &amp; u - \lambda &amp; 0 &amp; A_{36} &amp; 0 \\
-uw &amp; 0 &amp; u - \lambda &amp; 0 &amp; A_{47} \\
A_{61} &amp; A_{63} &amp; 0 &amp; u - \lambda &amp; 0 \\
A_{71} &amp; 0 &amp; A_{74} &amp; 0 &amp; u - \lambda \\
A_{81} &amp; A_{83} &amp; A_{84} &amp; A_{86} &amp; A_{87}
\end{vmatrix}
+ (u\gamma - \lambda)\begin{vmatrix}
A_{21} &amp; A_{23} &amp; A_{24} &amp; A_{26} &amp; A_{27} \\
-uv &amp; u - \lambda &amp; 0 &amp; A_{36} &amp; 0 \\
-uw &amp; 0 &amp; u - \lambda &amp; 0 &amp; A_{47} \\
A_{61} &amp; A_{63} &amp; 0 &amp; u - \lambda &amp; 0 \\
A_{71} &amp; 0 &amp; A_{74} &amp; 0 &amp; u - \lambda
\end{vmatrix} 
\end{align}\]

<p>We can rewrite this,</p>

\[\begin{align}
D_{1} &amp;= -(\gamma - 1)D_{11} + (u\gamma - \lambda)D_{12} \\
D_{2} &amp;= -(\gamma - 1)D_{21} + (u\gamma - \lambda)D_{22} \\
\therefore -\lambda&amp;\left[(1-\gamma)D_{11} + (u\gamma - \lambda)D_{12}\right] + (\gamma-1)D_{21} + (\lambda - u\gamma)D_{22} = 0
\end{align}\]

<p>Unfortunately, there’s no way around what we have to do next if we want to see this calculation through. The $D_{kl}$ are structured such that the simplest expansion we can break each of them down into involves three $4\times 4$ determinants per $D_{kl}$. The best decision we can make is to expand across the dimension with the simplest terms, yielding,</p>

\[\begin{align}
D_{11} &amp;= vD_{111} - (u - \lambda)D_{112} - A_{36}D_{113} \\
D_{12} &amp;= -vD_{121} + (u - \lambda)D_{122} + A_{36}D_{123} \\
D_{21} &amp;= -uvD_{211} - (u - \lambda)D_{212} - A_{36}D_{213} \\
D_{22} &amp;= uvD_{221} + (u - \lambda)D_{222} + A_{36}D_{223}
\end{align}\]

<p>where,</p>

\[\begin{align}
D_{111} &amp;= \\
D_{112} &amp;= \\
D_{113} &amp;= \\
D_{121} &amp;= \\
D_{122} &amp;= \\
D_{123} &amp;= \\
D_{211} &amp;= \\
D_{212} &amp;= \\
D_{213} &amp;= \\
D_{221} &amp;= \\
D_{222} &amp;= \\
D_{223} &amp;= 
\end{align}\]

<!-- same goes for $\mathbf{B} - \lambda\mathbf{I}$, and $\mathbf{C} - \lambda\mathbf{I}$,

$$
\mathbf{B} - \lambda\mathbf{I} = 
\begin{bmatrix}
\end{bmatrix}
$$

$$
\mathbf{C} - \lambda\mathbf{I} = 
\begin{bmatrix}
\end{bmatrix}
$$ -->

<!-- &nbsp;&nbsp;&nbsp;&nbsp; While there are numerical routines implemented in C, and C++, which compute the eigenvalues of a matrix, there is little recourse to symbolically computing them (except the expensive Mathematica software, of course). However, by looking at the previous examples of how to compute a determinant by hand, we can notice that the determinant of the sub-matrices are multiplied by a leading factor, which is a value in the primary matrix. If this value is 0, then the associated sub-matrix determinant does not need to be computed, which means that if we are clever, and the primary matrix is full of zeroes (like the Ideal MHD Flux Jacobians are), then things can be greatly simplified!   -->

<!-- &nbsp;&nbsp;&nbsp;&nbsp; Long ago, in Fortran77, high-performance libraries were written to implement numerical linear algebra routines that performed this kind of task, among others. Fortran77, or F77 as it is lovingly-referred to, is also the number of expletives one might utter when dealing with a language full of such idiosyncracies as requiring there to be a fixed number of leading whitespaces before every line (if you thought *Python* whitespace was bad). As the language matured, these routines were ported to Fortran90, a much more enjoyable version of Fortran, C, and C++. Now, bindings exist in many languages to access these high-performance libraries, as well as ports of them which run on a GPU.     -->

<!-- References -->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Trefethen and Bau, <em>Numerical Linear Algebra</em>, SIAM, 1997 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>

    </div>
    <footer>
  <div>
    <hr>
    <ul>
      <li><a href="mailto:russellmatt66@gmail.com">russellmatt66@gmail.com</a></li>
      <li><a href="https://github.com/russellmatt66">github.com/russellmatt66</a></li>
    </ul>
  </div>
</footer>

  </body>
</html>
